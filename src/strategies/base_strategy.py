"""
Base strategy class for trading strategies.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Dict, Any, Optional

from src.models.market import Market
from src.models.position import Position


class SignalType(str, Enum):
    """Signal type enumeration."""

    BUY = "buy"
    SELL = "sell"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        signal_type: Buy or sell
        market_id: Market identifier
        price: Target price
        confidence: Signal confidence (0-1)
        metadata: Additional signal information
        generated_at: Signal generation timestamp
    """

    signal_type: SignalType
    market_id: str
    price: float
    confidence: float = 1.0
    metadata: Dict[str, Any] = field(default_factory=dict)
    generated_at: datetime = field(default_factory=datetime.now)


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    All strategies should inherit from this class and implement:
    - generate_entry_signals(): Generate buy signals
    - generate_exit_signals(): Generate sell signals
    - on_market_update(): Handle market updates
    """

    def __init__(self, config: Dict[str, Any]):
        """
        Initialize strategy.

        Args:
            config: Strategy configuration dictionary
        """
        self.config = config
        self.logger = logging.getLogger(self.__class__.__name__)

        # Statistics
        self.signals_generated = 0
        self.trades_executed = 0
        self.started_at = datetime.now()

    @abstractmethod
    def generate_entry_signals(self, markets: List[Market]) -> List[Signal]:
        """
        Generate entry (buy) signals for tradeable markets.

        Args:
            markets: List of tradeable markets

        Returns:
            List of buy signals
        """
        pass

    @abstractmethod
    def generate_exit_signals(
        self, positions: List[Position], markets: Dict[str, Market]
    ) -> List[Signal]:
        """
        Generate exit (sell) signals for open positions.

        Args:
            positions: List of open positions
            markets: Dictionary of market_id -> Market

        Returns:
            List of sell signals
        """
        pass

    @abstractmethod
    def on_market_update(self, market: Market):
        """
        Handle market data update.

        Args:
            market: Updated market data
        """
        pass

    def filter_signals(
        self, signals: List[Signal], min_confidence: float = 0.0
    ) -> List[Signal]:
        """
        Filter signals by confidence threshold.

        Args:
            signals: List of signals to filter
            min_confidence: Minimum confidence threshold

        Returns:
            Filtered list of signals
        """
        return [s for s in signals if s.confidence >= min_confidence]

    def get_statistics(self) -> Dict[str, Any]:
        """
        Get strategy statistics.

        Returns:
            Dictionary of strategy statistics
        """
        runtime_seconds = (datetime.now() - self.started_at).total_seconds()

        return {
            "strategy_name": self.__class__.__name__,
            "signals_generated": self.signals_generated,
            "trades_executed": self.trades_executed,
            "runtime_seconds": runtime_seconds,
            "runtime_hours": runtime_seconds / 3600,
            "started_at": self.started_at.isoformat(),
        }

    def __str__(self) -> str:
        return f"{self.__class__.__name__}(signals={self.signals_generated}, trades={self.trades_executed})"

    def __repr__(self) -> str:
        return self.__str__()
